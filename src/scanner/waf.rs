//! WAF (Web Application Firewall) detection scanner
//!
//! Detects the presence of WAFs using passive header/cookie analysis
//! and active probing with known malicious payloads.

use crate::error::Result;
use crate::http::HttpClient;
use crate::models::{Finding, ScanConfig, Severity};
use async_trait::async_trait;
use tracing::debug;

/// Known WAF signatures for passive detection
struct WafSignature {
    name: &'static str,
    headers: &'static [(&'static str, &'static str)],
    cookies: &'static [&'static str],
    body_patterns: &'static [&'static str],
}

const WAF_SIGNATURES: &[WafSignature] = &[
    WafSignature {
        name: "Cloudflare",
        headers: &[
            ("cf-ray", ""),
            ("server", "cloudflare"),
            ("cf-cache-status", ""),
        ],
        cookies: &["__cfduid", "__cf_bm", "cf_clearance"],
        body_patterns: &["Attention Required! | Cloudflare", "cloudflare-nginx"],
    },
    WafSignature {
        name: "AWS WAF / CloudFront",
        headers: &[
            ("x-amzn-requestid", ""),
            ("x-amz-cf-id", ""),
            ("x-amz-cf-pop", ""),
        ],
        cookies: &["AWSALB", "AWSALBCORS", "aws-waf-token"],
        body_patterns: &["<h1>Request blocked</h1>"],
    },
    WafSignature {
        name: "ModSecurity",
        headers: &[("server", "mod_security"), ("server", "NOYB")],
        cookies: &[],
        body_patterns: &[
            "ModSecurity",
            "This error was generated by Mod_Security",
            "mod_security",
            "NOYB",
        ],
    },
    WafSignature {
        name: "Imperva / Incapsula",
        headers: &[("x-iinfo", ""), ("x-cdn", "Incapsula")],
        cookies: &["visid_incap_", "incap_ses_", "nlbi_"],
        body_patterns: &[
            "Incapsula incident ID",
            "/_Incapsula_Resource",
            "Request unsuccessful. Incapsula",
        ],
    },
    WafSignature {
        name: "Akamai",
        headers: &[
            ("x-akamai-transformed", ""),
            ("server", "AkamaiGHost"),
            ("x-akamai-request-id", ""),
        ],
        cookies: &["AKA_A2", "akamai_generated"],
        body_patterns: &["Access Denied - Akamai", "Reference&#32;&#35;"],
    },
    WafSignature {
        name: "F5 BIG-IP ASM",
        headers: &[("server", "BigIP"), ("x-wa-info", "")],
        cookies: &["BIGipServer", "TS0", "f5_cspm"],
        body_patterns: &[
            "The requested URL was rejected",
            "Please consult with your administrator",
        ],
    },
    WafSignature {
        name: "Sucuri",
        headers: &[
            ("server", "Sucuri"),
            ("x-sucuri-id", ""),
            ("x-sucuri-cache", ""),
        ],
        cookies: &["sucuri_cloudproxy"],
        body_patterns: &[
            "Access Denied - Sucuri Website Firewall",
            "Sucuri WebSite Firewall",
        ],
    },
    WafSignature {
        name: "Barracuda",
        headers: &[("server", "Barracuda")],
        cookies: &["barra_counter_session"],
        body_patterns: &["Barracuda Web Application Firewall"],
    },
    WafSignature {
        name: "Fortinet FortiWeb",
        headers: &[("server", "FortiWeb")],
        cookies: &["FORTIWAFSID"],
        body_patterns: &["FortiWeb", ".fwb_page_id"],
    },
];

/// Payloads used for active WAF detection
const PROBE_PAYLOADS: &[(&str, &str)] = &[
    ("sqli", "' OR 1=1 --"),
    ("xss", "<script>alert(1)</script>"),
    ("path_traversal", "../../etc/passwd"),
    ("rce", "; cat /etc/passwd"),
    (
        "xxe",
        "<!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]>",
    ),
];

/// Status codes commonly returned by WAFs when blocking
const WAF_BLOCK_STATUSES: &[u16] = &[403, 406, 429, 503];

pub struct WafScanner;

#[async_trait]
impl super::Scanner for WafScanner {
    fn name(&self) -> &str {
        "waf"
    }

    fn description(&self) -> &str {
        "Detects Web Application Firewalls (WAFs) via passive and active analysis"
    }

    async fn scan(
        &self,
        client: &HttpClient,
        config: &ScanConfig,
        _crawled_urls: &[String],
    ) -> Result<Vec<Finding>> {
        let mut findings = Vec::new();

        // Phase 1: Passive detection from normal GET
        let passive_result = passive_detect(client, &config.target).await;
        findings.extend(passive_result);

        // Phase 2: Active detection with malicious payloads
        let active_result = active_detect(client, &config.target).await;
        findings.extend(active_result);

        Ok(findings)
    }
}

/// Passive WAF detection: analyze headers, cookies, and body of a normal response
async fn passive_detect(client: &HttpClient, target: &str) -> Vec<Finding> {
    let mut findings = Vec::new();

    let response = match client.get(target).await {
        Ok(r) => r,
        Err(e) => {
            debug!("WAF passive detection: failed to GET {}: {}", target, e);
            return findings;
        }
    };

    let headers: Vec<(String, String)> = response
        .headers()
        .iter()
        .map(|(k, v)| {
            (
                k.as_str().to_lowercase(),
                v.to_str().unwrap_or("").to_lowercase(),
            )
        })
        .collect();

    let cookies: String = headers
        .iter()
        .filter(|(k, _)| k == "set-cookie")
        .map(|(_, v)| v.as_str())
        .collect::<Vec<&str>>()
        .join("; ");

    let body = response.text().await.unwrap_or_default();

    for sig in WAF_SIGNATURES {
        let mut evidence_parts: Vec<String> = Vec::new();

        // Check headers
        for (header_name, header_pattern) in sig.headers {
            for (name, value) in &headers {
                if name == *header_name
                    && (header_pattern.is_empty() || value.contains(header_pattern))
                {
                    evidence_parts.push(format!("Header matched: {}: {}", name, value));
                }
            }
        }

        // Check cookies
        for cookie_pattern in sig.cookies {
            if cookies
                .to_lowercase()
                .contains(&cookie_pattern.to_lowercase())
            {
                evidence_parts.push(format!("Cookie matched: {}", cookie_pattern));
            }
        }

        // Check body patterns
        let body_lower = body.to_lowercase();
        for pattern in sig.body_patterns {
            if body_lower.contains(&pattern.to_lowercase()) {
                evidence_parts.push(format!("Body pattern matched: {}", pattern));
            }
        }

        if !evidence_parts.is_empty() {
            findings.push(
                Finding::new(
                    format!("WAF Detected: {}", sig.name),
                    format!(
                        "A {} Web Application Firewall was detected protecting the target.",
                        sig.name
                    ),
                    Severity::Info,
                    "WAF Detection",
                    target,
                )
                .with_evidence(evidence_parts.join("\n"))
                .with_recommendation(
                    "WAF presence is noted for reconnaissance. Adjust testing techniques accordingly.",
                )
                .with_owasp("A05:2021 Security Misconfiguration"),
            );
        }
    }

    findings
}

/// Active WAF detection: send payloads and observe blocking behavior
async fn active_detect(client: &HttpClient, target: &str) -> Vec<Finding> {
    let mut findings = Vec::new();
    let base = target.trim_end_matches('/');

    // First, get a baseline response for comparison
    let baseline_status = match client.get(target).await {
        Ok(r) => r.status().as_u16(),
        Err(_) => return findings,
    };

    let mut blocked_by = Vec::new();

    for (payload_type, payload) in PROBE_PAYLOADS {
        let probe_url = format!("{}/?test={}", base, urlencoding_simple(payload));

        match client.get(&probe_url).await {
            Ok(resp) => {
                let status = resp.status().as_u16();
                let body = resp.text().await.unwrap_or_default();

                if WAF_BLOCK_STATUSES.contains(&status) && status != baseline_status {
                    let mut detected_waf = "Unknown WAF".to_string();

                    // Try to identify the specific WAF from the block page
                    let body_lower = body.to_lowercase();
                    for sig in WAF_SIGNATURES {
                        for pattern in sig.body_patterns {
                            if body_lower.contains(&pattern.to_lowercase()) {
                                detected_waf = sig.name.to_string();
                                break;
                            }
                        }
                    }

                    blocked_by.push(format!(
                        "{} payload blocked (HTTP {}): WAF identified as {}",
                        payload_type, status, detected_waf
                    ));
                }
            }
            Err(e) => {
                debug!(
                    "WAF active probe failed for {} payload: {}",
                    payload_type, e
                );
            }
        }
    }

    if !blocked_by.is_empty() {
        findings.push(
            Finding::new(
                "WAF Active Blocking Detected",
                "Active probing with known malicious payloads triggered WAF blocking responses.",
                Severity::Info,
                "WAF Detection",
                target,
            )
            .with_evidence(blocked_by.join("\n"))
            .with_recommendation(
                "WAF is actively blocking malicious payloads. Consider WAF bypass techniques for authorized testing.",
            )
            .with_owasp("A05:2021 Security Misconfiguration"),
        );
    }

    findings
}

/// Simple URL encoding for probe payloads
fn urlencoding_simple(input: &str) -> String {
    let mut result = String::with_capacity(input.len() * 3);
    for byte in input.bytes() {
        match byte {
            b'A'..=b'Z' | b'a'..=b'z' | b'0'..=b'9' | b'-' | b'_' | b'.' | b'~' => {
                result.push(byte as char);
            }
            _ => {
                result.push_str(&format!("%{:02X}", byte));
            }
        }
    }
    result
}
